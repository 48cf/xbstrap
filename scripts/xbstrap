#!/usr/bin/python3

import argparse
from enum import Enum
import errno
import os
import re
import shutil
import subprocess
import tarfile
import yaml

def try_mkdir(path):
	try:
		os.mkdir(path)
	except OSError as e:
		if e.errno != errno.EEXIST:
			raise

def try_rmtree(path):
	try:
		shutil.rmtree(path)
	except OSError as e:
		if e.errno != errno.ENOENT:
			raise

def replace_at_vars(string, resolve):
	def do_substitute(m):
		varname = m.group(1)
		result = resolve(varname)
		if result is None:
			raise RuntimeError("Unexpected substitution {}".format(varname))
		return result

	return re.sub(r'@(\w+)@', do_substitute, string)

class Config:
	def __init__(self, root_yml):
		self._root_yml = root_yml
		self._host_pkgs = dict()
		self._target_pkgs = dict()

		for pkg_yml in self._root_yml['host-packages']:
			pkg = HostPackage(self, pkg_yml)
			self._host_pkgs[pkg.name] = pkg

		for pkg_yml in self._root_yml['target-packages']:
			pkg = TargetPackage(self, pkg_yml)
			self._target_pkgs[pkg.name] = pkg

	@property
	def source_root(self):
		return os.path.join(os.getcwd(),
				os.path.dirname(os.readlink('bootstrap.link')))

	@property
	def build_root(self):
		return os.getcwd()

	def get_host_pkg(self, name):
		return self._host_pkgs[name]

	def get_target_pkg(self, name):
		return self._target_pkgs[name]

class ScriptStep:
	def __init__(self, step_yml):
		self._step_yml = step_yml

	@property
	def args(self):
		return self._step_yml['args']

	@property
	def environ(self):
		if 'environ' not in self._step_yml:
			return dict()
		return self._step_yml['environ']

class HostPackage:
	def __init__(self, cfg, pkg_yml):
		self._cfg = cfg
		self._pkg_yml = pkg_yml

	@property
	def has_shared_libs(self):
		if 'has_shared_libs' not in self._pkg_yml:
			return False
		return self._pkg_yml['has_shared_libs']

	@property
	def prefix_dir(self):
		return os.path.join(self._cfg.build_root, 'prefixes', self.name)

	@property
	def name(self):
		return self._pkg_yml['name']

	@property
	def dependencies(self):
		if 'dependencies' not in self._pkg_yml:
			return []
		yield from self._pkg_yml['dependencies']

class TargetPackage:
	def __init__(self, cfg, pkg_yml):
		self._cfg = cfg
		self._pkg_yml = pkg_yml
		self._build_steps = [ ]
		self._configure_steps = [ ]

		for step_yml in self._pkg_yml['configure']:
			self._configure_steps.append(ScriptStep(step_yml))
		for step_yml in self._pkg_yml['build']:
			self._build_steps.append(ScriptStep(step_yml))

	@property
	def source_dir(self):
		return os.path.join(self._cfg.source_root, self.name)

	@property
	def build_dir(self):
		return os.path.join(self._cfg.build_root, 'native', 'native-' + self.name)

	@property
	def collect_dir(self):
		return os.path.join(self._cfg.build_root, 'packages', self.name + '.collect')

	@property
	def archive_file(self):
		return os.path.join(self._cfg.build_root, 'packages', self.name + '.tar.gz')

	@property
	def name(self):
		return self._pkg_yml['name']

	@property
	def host_deps(self):
		yield from self._pkg_yml['host-deps']

	@property
	def configure_steps(self):
		yield from self._configure_steps

	@property
	def build_steps(self):
		yield from self._build_steps

def config_for_dir():
	with open('bootstrap.link', 'r') as f:
		return Config(yaml.load(f))

class EnvironmentComposer:
	def __init__(self):
		self.path_dirs = [ ]
		self.shared_lib_dirs = [ ]

	def compose(self):
		environ = os.environ.copy()
		self._append_dirs(environ, 'PATH', self.path_dirs)
		self._append_dirs(environ, 'LD_LIBRARY_PATH', self.shared_lib_dirs)
		print(self.shared_lib_dirs)
		return environ

	def _append_dirs(self, environ, varname, dirs):
		if not dirs:
			return
		joined = ':'.join(dirs)
		if varname in environ and environ[varname]:
			environ[varname] += ':' + joined
		else:
			environ[varname] = joined

def run_tool(cfg, args, host_pkgs=[], workdir=None, extra_environ=dict()):
	pkg_queue = []
	pkg_visited = set()

	for pkg in host_pkgs:
		assert pkg.name not in pkg_visited
		pkg_queue.append(pkg)
		pkg_visited.add(pkg.name)

	i = 0 # Need index-based loop as pkg_queue is mutated in the loop.
	while i < len(pkg_queue):
		pkg = pkg_queue[i]
		for dep_name in pkg.dependencies:
			if dep_name in pkg_visited:
				continue
			dep_pkg = cfg.get_host_pkg(dep_name)
			pkg_queue.append(dep_pkg)
			pkg_visited.add(dep_name)
		i += 1

	composer = EnvironmentComposer()
	for pkg in pkg_queue:
		composer.path_dirs.append(os.path.join(pkg.prefix_dir, 'bin'))
		if pkg.has_shared_libs:
			composer.shared_lib_dirs.append(os.path.join(pkg.prefix_dir, 'lib'))
	environ = composer.compose()
	environ.update(extra_environ)

	subprocess.check_call(args, env=environ, cwd=workdir)

# ---------------------------------------------------------------------------------------
# Package building.
# ---------------------------------------------------------------------------------------

def configure_pkg(cfg, pkg):
	try_rmtree(pkg.build_dir)
	try_mkdir(pkg.build_dir)

	for step in pkg.configure_steps:
		host_pkgs = []
		for dep_name in pkg.host_deps:
			host_pkgs.append(cfg.get_host_pkg(dep_name))

		def substitute(varname):
			if varname == 'SOURCE_ROOT':
				return cfg.source_root
			elif varname == 'BUILD_ROOT':
				return cfg.build_root
			elif varname == 'PKG_SOURCE_DIR':
				return pkg.source_dir

		args = [replace_at_vars(arg, substitute) for arg in step.args]

		environ = dict()
		for (key, value) in step.environ.items():
			environ[key] = replace_at_vars(value, substitute)

		run_tool(cfg, args, host_pkgs=host_pkgs, workdir=pkg.build_dir,
				extra_environ=environ)

def build_pkg(cfg, pkg):
	try_mkdir('packages')
	try_rmtree(pkg.collect_dir)
	os.mkdir(pkg.collect_dir)

	for step in pkg.build_steps:
		host_pkgs = []
		for dep_name in pkg.host_deps:
			host_pkgs.append(cfg.get_host_pkg(dep_name))

		def substitute(varname):
			if varname == 'PKG_COLLECT_DIR':
				return pkg.collect_dir

		environ = dict()
		for (key, value) in step.environ.items():
			environ[key] = replace_at_vars(value, substitute)

		run_tool(cfg, step.args, host_pkgs=host_pkgs, workdir=pkg.build_dir,
				extra_environ=environ)

	with tarfile.open(pkg.archive_file, 'w|gz') as tar:
		for ent in os.listdir(pkg.collect_dir):
			tar.add(os.path.join(pkg.collect_dir, ent), arcname=ent)

def install_pkg(cfg, pkg):
	with tarfile.open(pkg.archive_file, 'r|gz') as tar:
		tar.extractall(os.path.join(cfg.build_root, 'system-root'))

# ---------------------------------------------------------------------------------------
# Build planning.
# ---------------------------------------------------------------------------------------

class Action(Enum):
	NULL = 0
	CONFIGURE = 1
	BUILD = 2
	INSTALL = 3
Action.strings = {
	Action.CONFIGURE: 'configure',
	Action.BUILD: 'build',
	Action.INSTALL: 'install'
}

def compute_plan(desired):
	def expand(action, pkg):
		links = [ ]
		if action == Action.INSTALL:
			links.append((action.BUILD, pkg))
		if action == Action.BUILD:
			links.append((action.CONFIGURE, pkg))
		return links

	class State(Enum):
		NULL = 0
		EXPANDING = 1
		ORDERED = 2

	order = [ ]

	stack = [ ]
	state = dict()

	def visit(action, pkg):
		if (action, pkg.name) not in state:
			links = expand(action, pkg)
			state[(action, pkg.name)] = State.EXPANDING
			stack.append((action, pkg, links))
		elif state[(action, pkg.name)] == State.EXPANDING:
			raise RuntimeError("Package has circular dependencies")
		else:
			# Packages that are already ordered do not need to be considered again.
			assert state[(action, pkg.name)] == State.ORDERED

	for (action, pkg) in desired:
		visit(action, pkg)

		while stack:
			(action, pkg, rem_links) = stack[-1]
			if not rem_links:
				assert state[(action, pkg.name)] == State.EXPANDING
				state[(action, pkg.name)] = State.ORDERED
				stack.pop()
				order.append((action, pkg))
			else:
				(link_action, link_pkg) = rem_links.pop()
				visit(link_action, link_pkg)
	return order

def run_plan(cfg, plan):
	print('Executing the following plan:')
	for (action, pkg) in plan:
		print('    {:12} {}'.format(Action.strings[action], pkg.name))

	for (action, pkg) in plan:
		if action == Action.CONFIGURE:
			configure_pkg(cfg, pkg)
		elif action == Action.BUILD:
			build_pkg(cfg, pkg)
		elif action == Action.INSTALL:
			install_pkg(cfg, pkg)
		else:
			raise AssertionError("Unexpected action")

# ---------------------------------------------------------------------------------------
# Command line parsing.
# ---------------------------------------------------------------------------------------

main_parser = argparse.ArgumentParser()
main_subparsers = main_parser.add_subparsers(dest='command')

def do_run(args):
	cfg = config_for_dir()
	run_tool(cfg, args.args)

do_run.parser = main_subparsers.add_parser('run')
do_run.parser.add_argument('args', nargs=argparse.REMAINDER)

def do_init(args):
	if not os.access(os.path.join(args.src_root, 'bootstrap.yml'), os.F_OK):
		raise RuntimeError("Given src_root does not contain a bootstrap.yml")
	os.symlink(os.path.join(args.src_root, 'bootstrap.yml'), 'bootstrap.link')

do_init.parser = main_subparsers.add_parser('init')
do_init.parser.add_argument('src_root', type=str)

def do_configure(args):
	cfg = config_for_dir()
	pkg = cfg.get_target_pkg(args.package)
	plan = compute_plan([(Action.CONFIGURE, pkg)])
	run_plan(cfg, plan)

do_configure.parser = main_subparsers.add_parser('configure')
do_configure.parser.add_argument('package', type=str)

def do_build(args):
	cfg = config_for_dir()
	pkg = cfg.get_target_pkg(args.package)
	plan = compute_plan([(Action.BUILD, pkg)])
	run_plan(cfg, plan)

do_build.parser = main_subparsers.add_parser('build')
do_build.parser.add_argument('package', type=str)

def do_install(args):
	cfg = config_for_dir()
	pkg = cfg.get_target_pkg(args.package)
	plan = compute_plan([(Action.INSTALL, pkg)])
	run_plan(cfg, plan)

do_install.parser = main_subparsers.add_parser('install')
do_install.parser.add_argument('package', type=str)

args = main_parser.parse_args()

if args.command == 'init':
	do_init(args)
elif args.command == 'run':
	do_run(args)
elif args.command == 'configure':
	do_configure(args)
elif args.command == 'build':
	do_build(args)
elif args.command == 'install':
	do_install(args)
else:
	assert not "Unexpected command"

