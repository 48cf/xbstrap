#!/usr/bin/python3

import argparse
from enum import Enum
import errno
import os
import re
import shutil
import subprocess
import tarfile
import yaml

def touch(path):
	with open(path, 'a') as f:
		pass

def try_mkdir(path):
	try:
		os.mkdir(path)
	except OSError as e:
		if e.errno != errno.EEXIST:
			raise

def try_unlink(path):
	try:
		os.unlink(path)
	except OSError as e:
		if e.errno != errno.ENOENT:
			raise

def try_rmtree(path):
	try:
		shutil.rmtree(path)
	except OSError as e:
		if e.errno != errno.ENOENT:
			raise

def replace_at_vars(string, resolve):
	def do_substitute(m):
		varname = m.group(1)
		result = resolve(varname)
		if result is None:
			raise RuntimeError("Unexpected substitution {}".format(varname))
		return result

	return re.sub(r'@(\w+)@', do_substitute, string)

class Config:
	def __init__(self, root_yml):
		self._root_yml = root_yml
		self._tool_pkgs = dict()
		self._tool_stages = dict()
		self._target_pkgs = dict()

		for pkg_yml in self._root_yml['tools']:
			pkg = HostPackage(self, pkg_yml)
			self._tool_pkgs[pkg.name] = pkg

		for pkg_yml in self._root_yml['packages']:
			pkg = TargetPackage(self, pkg_yml)
			self._target_pkgs[pkg.name] = pkg

	@property
	def source_root(self):
		return os.path.join(os.getcwd(),
				os.path.dirname(os.readlink('bootstrap.link')))

	@property
	def build_root(self):
		return os.getcwd()

	@property
	def sysroot_dir(self):
		return os.path.join(self.build_root, 'system-root')

	def get_tool_pkg(self, name):
		return self._tool_pkgs[name]

	def all_target_pkgs(self):
		yield from self._target_pkgs.values()

	def get_target_pkg(self, name):
		return self._target_pkgs[name]

class ScriptStep:
	def __init__(self, step_yml):
		self._step_yml = step_yml

	@property
	def args(self):
		return self._step_yml['args']

	@property
	def environ(self):
		if 'environ' not in self._step_yml:
			return dict()
		return self._step_yml['environ']

class HostStage:
	def __init__(self, cfg, pkg, inherited, pkg_yml):
		self._cfg = cfg
		self._pkg = pkg
		self._inherited = inherited
		self._stage_yml = pkg_yml
		self._compile_steps = [ ]
		self._install_steps = [ ]

		if 'compile' in self._stage_yml:
			for step_yml in self._stage_yml['compile']:
				self._compile_steps.append(ScriptStep(step_yml))
		if 'install' in self._stage_yml:
			for step_yml in self._stage_yml['install']:
				self._install_steps.append(ScriptStep(step_yml))

	@property
	def pkg(self):
		return self._pkg

	@property
	def stage_name(self):
		if self._inherited:
			return None
		return self._stage_yml['name']

	@property
	def subject_id(self):
		return (self._pkg.name, self.stage_name)
	
	@property
	def self_required(self):
		if 'self_required' not in self._stage_yml:
			return False
		return self._stage_yml['self_required']

	@property
	def compile_steps(self):
		yield from self._compile_steps

	@property
	def install_steps(self):
		yield from self._install_steps

	def check_if_compiled(self):
		stage_spec = ''
		if not self._inherited:
			stage_spec = '@' + self.stage_name
		path = os.path.join(self._pkg.build_dir, 'xbstrap' + stage_spec + '.tool-compiled')
		return os.access(path, os.F_OK)

	def mark_as_compiled(self):
		stage_spec = ''
		if not self._inherited:
			stage_spec = '@' + self.stage_name
		touch(os.path.join(self._pkg.build_dir, 'xbstrap' + stage_spec + '.tool-compiled'))

	def check_if_installed(self):
		stage_spec = ''
		if not self._inherited:
			stage_spec = '@' + self.stage_name
		path = os.path.join(self._pkg.prefix_dir, 'etc', 'xbstrap',
				self._pkg.name + stage_spec + '.tool-installed')
		return os.access(path, os.F_OK)

	def mark_as_installed(self):
		stage_spec = ''
		if not self._inherited:
			stage_spec = '@' + self.stage_name
		try_mkdir(os.path.join(self._pkg.prefix_dir, 'etc'))
		try_mkdir(os.path.join(self._pkg.prefix_dir, 'etc', 'xbstrap'))
		path = os.path.join(self._pkg.prefix_dir, 'etc', 'xbstrap',
				self._pkg.name + stage_spec + '.tool-installed')
		touch(path)


class HostPackage:
	def __init__(self, cfg, pkg_yml):
		self._cfg = cfg
		self._pkg_yml = pkg_yml
		self._configure_steps = [ ]
		self._stages = dict()

		if 'stages' in self._pkg_yml:
			for stage_yml in self._pkg_yml['stages']:
				stage = HostStage(self._cfg, self, False, stage_yml)
				self._stages[stage.stage_name] = stage
		else:
			stage = HostStage(self._cfg, self, True, self._pkg_yml)
			self._stages[stage.stage_name] = stage

		if 'configure' in self._pkg_yml:
			for step_yml in self._pkg_yml['configure']:
				self._configure_steps.append(ScriptStep(step_yml))

	@property
	def has_shared_libs(self):
		if 'has_shared_libs' not in self._pkg_yml:
			return False
		return self._pkg_yml['has_shared_libs']

	@property
	def source_dir(self):
		if 'source_dir' in self._pkg_yml:
			return os.path.join(self._cfg.source_root, self._pkg_yml['source_dir'])
		return os.path.join(self._cfg.source_root, self.name)

	@property
	def build_dir(self):
		return os.path.join(self._cfg.build_root, 'tool-builds', self.name)

	@property
	def prefix_dir(self):
		return os.path.join(self._cfg.build_root, 'prefixes', self.name)

	@property
	def name(self):
		return self._pkg_yml['name']

	@property
	def subject_id(self):
		return self.name

	def all_stages(self):
		yield from self._stages.values()

	def get_stage(self, name):
		return self._stages[name]

	@property
	def tools_required(self):
		if 'tools_required' not in self._pkg_yml:
			return []
		yield from self._pkg_yml['tools_required']

	@property
	def configure_steps(self):
		yield from self._configure_steps

	def check_if_configured(self):
		return os.access(os.path.join(self.build_dir, 'xbstrap.tool-configured'), os.F_OK)

	def mark_as_configured(self):
		touch(os.path.join(self.build_dir, 'xbstrap.tool-configured'))

class TargetPackage:
	def __init__(self, cfg, pkg_yml):
		self._cfg = cfg
		self._pkg_yml = pkg_yml
		self._configure_steps = [ ]
		self._build_steps = [ ]

		for step_yml in self._pkg_yml['configure']:
			self._configure_steps.append(ScriptStep(step_yml))
		for step_yml in self._pkg_yml['build']:
			self._build_steps.append(ScriptStep(step_yml))

	@property
	def source_dir(self):
		if 'source_dir' in self._pkg_yml:
			return os.path.join(self._cfg.source_root, self._pkg_yml['source_dir'])
		return os.path.join(self._cfg.source_root, self.name)

	@property
	def build_dir(self):
		return os.path.join(self._cfg.build_root, 'native', 'native-' + self.name)

	@property
	def collect_dir(self):
		return os.path.join(self._cfg.build_root, 'packages', self.name + '.collect')

	@property
	def archive_file(self):
		return os.path.join(self._cfg.build_root, 'packages', self.name + '.tar.gz')

	@property
	def name(self):
		return self._pkg_yml['name']

	@property
	def subject_id(self):
		return self.name

	@property
	def is_implict_package(self):
		if 'implict_package' not in self._pkg_yml:
			return False
		return self._pkg_yml['implict_package']

	@property
	def tools_required(self):
		for yml in self._pkg_yml['tools_required']:
			if isinstance(yml, str):
				yield yml
			else:
				assert isinstance(yml, dict)
				yield yml['tool']

	@property
	def tool_stages_required(self):
		for yml in self._pkg_yml['tools_required']:
			if isinstance(yml, str):
				yield (yml, None)
			else:
				assert isinstance(yml, dict)
				yield (yml['tool'], yml['stage'])

	@property
	def pkg_dependencies(self):
		if 'pkgs_required' not in self._pkg_yml:
			return []
		yield from self._pkg_yml['pkgs_required']

	@property
	def configure_steps(self):
		yield from self._configure_steps

	@property
	def build_steps(self):
		yield from self._build_steps

	def check_if_configured(self):
		return os.access(os.path.join(self.build_dir, 'xbstrap.configured'), os.F_OK)

	def mark_as_configured(self):
		touch(os.path.join(self.build_dir, 'xbstrap.configured'))

	def check_archive(self):
		return os.access(self.archive_file, os.F_OK)

	def check_if_installed(self):
		path = os.path.join(self._cfg.sysroot_dir, 'etc', 'xbstrap', self.name + '.installed')
		return os.access(path, os.F_OK)

	def mark_as_installed(self):
		try_mkdir(os.path.join(self._cfg.sysroot_dir, 'etc'))
		try_mkdir(os.path.join(self._cfg.sysroot_dir, 'etc', 'xbstrap'))
		path = os.path.join(self._cfg.sysroot_dir, 'etc', 'xbstrap', self.name + '.installed')
		touch(path)

def config_for_dir():
	with open('bootstrap.link', 'r') as f:
		return Config(yaml.load(f))

class EnvironmentComposer:
	def __init__(self):
		self.path_dirs = [ ]
		self.shared_lib_dirs = [ ]

	def compose(self):
		environ = os.environ.copy()
		self._append_dirs(environ, 'PATH', self.path_dirs)
		self._append_dirs(environ, 'LD_LIBRARY_PATH', self.shared_lib_dirs)
		return environ

	def _append_dirs(self, environ, varname, dirs):
		if not dirs:
			return
		joined = ':'.join(dirs)
		if varname in environ and environ[varname]:
			environ[varname] += ':' + joined
		else:
			environ[varname] = joined

def run_tool(cfg, args, tool_pkgs=[], workdir=None, extra_environ=dict()):
	pkg_queue = []
	pkg_visited = set()

	for pkg in tool_pkgs:
		assert pkg.name not in pkg_visited
		pkg_queue.append(pkg)
		pkg_visited.add(pkg.name)

	i = 0 # Need index-based loop as pkg_queue is mutated in the loop.
	while i < len(pkg_queue):
		pkg = pkg_queue[i]
		for dep_name in pkg.tools_required:
			if dep_name in pkg_visited:
				continue
			dep_pkg = cfg.get_tool_pkg(dep_name)
			pkg_queue.append(dep_pkg)
			pkg_visited.add(dep_name)
		i += 1

	composer = EnvironmentComposer()
	for pkg in pkg_queue:
		composer.path_dirs.append(os.path.join(pkg.prefix_dir, 'bin'))
		if pkg.has_shared_libs:
			composer.shared_lib_dirs.append(os.path.join(pkg.prefix_dir, 'lib'))
	environ = composer.compose()
	environ.update(extra_environ)

	subprocess.check_call(args, env=environ, cwd=workdir)

def postprocess_libtool(cfg, pkg):
	for libdir in ['lib', 'usr/lib']:
		filelist = []
		try:
			filelist = os.listdir(os.path.join(pkg.collect_dir, libdir))
		except OSError as e:
			if e.errno != errno.ENOENT:
				raise

		for ent in filelist:
			if not ent.endswith('.la'):
				continue
			print('xbstrap: Removing libtool file {}'.format(ent))
			os.unlink(os.path.join(pkg.collect_dir, libdir, ent))

# ---------------------------------------------------------------------------------------
# Tool building.
# ---------------------------------------------------------------------------------------

def configure_tool(cfg, pkg):
	try_mkdir(os.path.join(cfg.build_root, 'tool-builds'))
	try_rmtree(pkg.build_dir)
	try_mkdir(pkg.build_dir)

	for step in pkg.configure_steps:
		tool_pkgs = []
		for dep_name in pkg.tools_required:
			tool_pkgs.append(cfg.get_tool_pkg(dep_name))

		def substitute(varname):
			if varname == 'SOURCE_ROOT':
				return cfg.source_root
			elif varname == 'BUILD_ROOT':
				return cfg.build_root
			elif varname == 'SYSROOT_DIR':
				return cfg.sysroot_dir
			elif varname == 'PKG_SOURCE_DIR':
				return pkg.source_dir
			elif varname == 'PREFIX':
				return pkg.prefix_dir

		args = [replace_at_vars(arg, substitute) for arg in step.args]

		environ = dict()
		for (key, value) in step.environ.items():
			environ[key] = replace_at_vars(value, substitute)

		run_tool(cfg, args, tool_pkgs=tool_pkgs, workdir=pkg.build_dir,
				extra_environ=environ)

	pkg.mark_as_configured()

def compile_tool_stage(cfg, stage):
	pkg = stage.pkg

	for step in stage.compile_steps:
		tool_pkgs = []
		for dep_name in pkg.tools_required:
			tool_pkgs.append(cfg.get_tool_pkg(dep_name))
		if stage.self_required:
			tool_pkgs.append(pkg)

		def substitute(varname):
			if varname == 'PARALLELISM':
				nthreads = len(os.sched_getaffinity(0))
				return str(nthreads)

		args = [replace_at_vars(arg, substitute) for arg in step.args]

		environ = dict()
		for (key, value) in step.environ.items():
			environ[key] = replace_at_vars(value, substitute)

		run_tool(cfg, args, tool_pkgs=tool_pkgs, workdir=pkg.build_dir,
				extra_environ=environ)

	stage.mark_as_compiled()

def install_tool_stage(cfg, stage):
	pkg = stage.pkg

	try_mkdir(os.path.join(cfg.build_root, 'prefixes'))
	try_rmtree(pkg.prefix_dir)
	try_mkdir(pkg.prefix_dir)

	for step in stage.install_steps:
		tool_pkgs = []
		for dep_name in pkg.tools_required:
			tool_pkgs.append(cfg.get_tool_pkg(dep_name))
		if stage.self_required:
			tool_pkgs.append(pkg)

		def substitute(varname):
			if varname == 'PREFIX':
				return pkg.prefix_dir

		args = [replace_at_vars(arg, substitute) for arg in step.args]

		environ = dict()
		for (key, value) in step.environ.items():
			environ[key] = replace_at_vars(value, substitute)

		run_tool(cfg, args, tool_pkgs=tool_pkgs, workdir=pkg.build_dir,
				extra_environ=environ)

	stage.mark_as_installed()

# ---------------------------------------------------------------------------------------
# Package building.
# ---------------------------------------------------------------------------------------

def configure_pkg(cfg, pkg):
	try_mkdir(os.path.join(cfg.build_root, 'native'))
	try_rmtree(pkg.build_dir)
	try_mkdir(pkg.build_dir)

	for step in pkg.configure_steps:
		tool_pkgs = []
		for dep_name in pkg.tools_required:
			tool_pkgs.append(cfg.get_tool_pkg(dep_name))

		def substitute(varname):
			if varname == 'SOURCE_ROOT':
				return cfg.source_root
			elif varname == 'BUILD_ROOT':
				return cfg.build_root
			elif varname == 'PKG_SOURCE_DIR':
				return pkg.source_dir

		args = [replace_at_vars(arg, substitute) for arg in step.args]

		environ = dict()
		for (key, value) in step.environ.items():
			environ[key] = replace_at_vars(value, substitute)

		run_tool(cfg, args, tool_pkgs=tool_pkgs, workdir=pkg.build_dir,
				extra_environ=environ)

	pkg.mark_as_configured()

def build_pkg(cfg, pkg):
	try_mkdir('packages')
	try_rmtree(pkg.collect_dir)
	os.mkdir(pkg.collect_dir)

	for step in pkg.build_steps:
		tool_pkgs = []
		for dep_name in pkg.tools_required:
			tool_pkgs.append(cfg.get_tool_pkg(dep_name))

		def substitute(varname):
			if varname == 'PARALLELISM':
				nthreads = len(os.sched_getaffinity(0))
				return str(nthreads)
			if varname == 'PKG_COLLECT_DIR':
				return pkg.collect_dir

		args = [replace_at_vars(arg, substitute) for arg in step.args]

		environ = dict()
		for (key, value) in step.environ.items():
			environ[key] = replace_at_vars(value, substitute)

		run_tool(cfg, args, tool_pkgs=tool_pkgs, workdir=pkg.build_dir,
				extra_environ=environ)

	postprocess_libtool(cfg, pkg)

	with tarfile.open(pkg.archive_file, 'w|gz') as tar:
		for ent in os.listdir(pkg.collect_dir):
			tar.add(os.path.join(pkg.collect_dir, ent), arcname=ent)

def install_pkg(cfg, pkg):
	try_mkdir(cfg.sysroot_dir)

	with tarfile.open(pkg.archive_file, 'r|gz') as tar:
		for info in tar:
			if not info.isdir():
				try_unlink(os.path.join(cfg.sysroot_dir, info.name))
			tar.extract(info, cfg.sysroot_dir)

	pkg.mark_as_installed()

# ---------------------------------------------------------------------------------------
# Build planning.
# ---------------------------------------------------------------------------------------

class Action(Enum):
	NULL = 0
	# Tool-related actions.
	CONFIGURE_TOOL = 1
	COMPILE_TOOL_STAGE = 2
	INSTALL_TOOL_STAGE = 3
	# Package-related actions.
	CONFIGURE_PKG = 4
	BUILD_PKG = 5
	INSTALL_PKG = 6
	# "Virtual" actions that are only used during planning.
	# The ENSURE_X_INSTALLED action recursively expand to ENSURE_X_INSTALLED of dependencies.
	# They only expand to INSTALL_X if the given package is not installed.
	# This way, recursive installation dependencies are handed correctly,
	# even if users delete packages from the sysroot.
	ENSURE_TOOL_INSTALLED = 7
	ENSURE_PKG_INSTALLED = 7

	def is_virtual(self):
		return self == Action.ENSURE_PKG_INSTALLED

Action.strings = {
	Action.CONFIGURE_TOOL: 'configure-tool',
	Action.COMPILE_TOOL_STAGE: 'compile-tool',
	Action.INSTALL_TOOL_STAGE: 'install-tool',
	Action.CONFIGURE_PKG: 'configure',
	Action.BUILD_PKG: 'build',
	Action.INSTALL_PKG: 'install',
	Action.ENSURE_TOOL_INSTALLED: 'install-tool?',
	Action.ENSURE_PKG_INSTALLED: 'install?'
}

def expand_plan(cfg, action, subject):
	links = [ ]

	def add_target_pkg_dependencies():
		# Add implict target dependencies.
		if not subject.is_implict_package:
			for implicit in cfg.all_target_pkgs():
				if implicit.is_implict_package:
					links.append((action.ENSURE_PKG_INSTALLED, implicit))

		for dep_name in subject.pkg_dependencies:
			dep_pkg = cfg.get_target_pkg(dep_name)
			links.append((action.ENSURE_PKG_INSTALLED, dep_pkg))

	def add_target_tool_dependencies():
		for (pkg_name, stage_name) in subject.tool_stages_required:
			tool_pkg = cfg.get_tool_pkg(pkg_name)
			tool_stage = tool_pkg.get_stage(stage_name)
			links.append((action.ENSURE_TOOL_INSTALLED, tool_stage))

	if action == Action.CONFIGURE_TOOL:
		pass
	elif action == Action.COMPILE_TOOL_STAGE:
		if not subject.pkg.check_if_configured():
			links.append((action.CONFIGURE_TOOL, subject.pkg))
	elif action == Action.INSTALL_TOOL_STAGE:
		if not subject.check_if_compiled():
			links.append((action.COMPILE_TOOL_STAGE, subject))
	if action == Action.CONFIGURE_PKG:
		# Configuration requires all dependencies to be present.
		add_target_pkg_dependencies()
		add_target_tool_dependencies()
	elif action == Action.BUILD_PKG:
		if not subject.check_if_configured():
			links.append((action.CONFIGURE_PKG, subject))

		# Usually dependencies will already be installed during the configuration phase.
		# However, if the sysroot is removed, we might need to install again.
		add_target_pkg_dependencies()
		add_target_tool_dependencies()
	elif action == Action.INSTALL_PKG:
		if not subject.check_archive():
			links.append((action.BUILD_PKG, subject))

		# See Action.BUILD_PKG for rationale.
		add_target_pkg_dependencies()
	elif action == Action.ENSURE_TOOL_INSTALLED:
		if not subject.check_if_installed():
			links.append((action.INSTALL_TOOL_STAGE, subject))
	elif action == Action.ENSURE_PKG_INSTALLED:
		if not subject.check_if_installed():
			links.append((action.INSTALL_PKG, subject))

		# See Action.BUILD_PKG for rationale.
		add_target_pkg_dependencies()

	return links

def compute_plan(cfg, desired):
	class State(Enum):
		NULL = 0
		EXPANDING = 1
		ORDERED = 2

	order = [ ]

	# The following code does a topologic sort of the desired items.
	# It lazily expands their dependencies using expand_plan().
	stack = [ ]
	state = dict()

	def visit(action, subject):
		if (action, subject.subject_id) not in state:
			links = expand_plan(cfg, action, subject)
			state[(action, subject.subject_id)] = State.EXPANDING
			stack.append((action, subject, links))
		elif state[(action, subject.subject_id)] == State.EXPANDING:
			raise RuntimeError("Package has circular dependencies")
		else:
			# Packages that are already ordered do not need to be considered again.
			assert state[(action, subject.subject_id)] == State.ORDERED

	for (action, subject) in desired:
		visit(action, subject)

		while stack:
			(action, subject, rem_links) = stack[-1]
			if not rem_links:
				assert state[(action, subject.subject_id)] == State.EXPANDING
				state[(action, subject.subject_id)] = State.ORDERED
				stack.pop()
				if not action.is_virtual():
					order.append((action, subject))
			else:
				(link_action, link_subject) = rem_links.pop()
				visit(link_action, link_subject)
	return order

def run_plan(cfg, plan):
	print('Executing the following plan:')
	for (action, subject) in plan:
		if isinstance(subject, HostStage):
			if subject.stage_name:
				print('    {:12} {}, stage: {}'.format(Action.strings[action],
						subject.pkg.name, subject.stage_name))
			else:
				print('    {:12} {}'.format(Action.strings[action], subject.pkg.name))
		else:
			print('    {:12} {}'.format(Action.strings[action], subject.name))

	for (action, subject) in plan:
		if action == Action.CONFIGURE_TOOL:
			configure_tool(cfg, subject)
		elif action == Action.COMPILE_TOOL_STAGE:
			compile_tool_stage(cfg, subject)
		elif action == Action.INSTALL_TOOL_STAGE:
			install_tool_stage(cfg, subject)
		elif action == Action.CONFIGURE_PKG:
			configure_pkg(cfg, subject)
		elif action == Action.BUILD_PKG:
			build_pkg(cfg, subject)
		elif action == Action.INSTALL_PKG:
			install_pkg(cfg, subject)
		else:
			raise AssertionError("Unexpected action")

# ---------------------------------------------------------------------------------------
# Command line parsing.
# ---------------------------------------------------------------------------------------

main_parser = argparse.ArgumentParser()
main_subparsers = main_parser.add_subparsers(dest='command')

def do_run(args):
	cfg = config_for_dir()

	tool_pkgs = []
	for name in args.t:
		tool_pkgs.append(cfg.get_tool_pkg(name))

	run_tool(cfg, args.args, tool_pkgs=tool_pkgs)

do_run.parser = main_subparsers.add_parser('run')
do_run.parser.add_argument('-t', action='append')
do_run.parser.add_argument('args', nargs=argparse.REMAINDER)

def do_init(args):
	if not os.access(os.path.join(args.src_root, 'bootstrap.yml'), os.F_OK):
		raise RuntimeError("Given src_root does not contain a bootstrap.yml")
	os.symlink(os.path.join(args.src_root, 'bootstrap.yml'), 'bootstrap.link')

do_init.parser = main_subparsers.add_parser('init')
do_init.parser.add_argument('src_root', type=str)

def do_configure_tool(args):
	cfg = config_for_dir()
	pkg = cfg.get_tool_pkg(args.package)
	plan = compute_plan(cfg, [(Action.CONFIGURE_TOOL, pkg)])
	run_plan(cfg, plan)

do_configure_tool.parser = main_subparsers.add_parser('configure-tool')
do_configure_tool.parser.add_argument('package', type=str)

def do_compile_tool(args):
	cfg = config_for_dir()
	pkg = cfg.get_tool_pkg(args.package)
	plan = compute_plan(cfg, [(Action.COMPILE_TOOL_STAGE, stage) for stage in pkg.all_stages()])
	run_plan(cfg, plan)

do_compile_tool.parser = main_subparsers.add_parser('compile-tool')
do_compile_tool.parser.add_argument('package', type=str)

def do_install_tool(args):
	cfg = config_for_dir()
	pkg = cfg.get_tool_pkg(args.package)
	plan = compute_plan(cfg, [(Action.INSTALL_TOOL_STAGE, stage) for stage in pkg.all_stages()])
	run_plan(cfg, plan)

do_install_tool.parser = main_subparsers.add_parser('install-tool')
do_install_tool.parser.add_argument('package', type=str)

def do_configure(args):
	cfg = config_for_dir()
	pkg = cfg.get_target_pkg(args.package)
	plan = compute_plan(cfg, [(Action.CONFIGURE_PKG, pkg)])
	run_plan(cfg, plan)

do_configure.parser = main_subparsers.add_parser('configure')
do_configure.parser.add_argument('package', type=str)

def do_build(args):
	cfg = config_for_dir()
	pkg = cfg.get_target_pkg(args.package)
	plan = compute_plan(cfg, [(Action.BUILD_PKG, pkg)])
	run_plan(cfg, plan)

do_build.parser = main_subparsers.add_parser('build')
do_build.parser.add_argument('package', type=str)

def do_install(args):
	cfg = config_for_dir()
	pkg = cfg.get_target_pkg(args.package)
	plan = compute_plan(cfg, [(Action.INSTALL_PKG, pkg)])
	run_plan(cfg, plan)

do_install.parser = main_subparsers.add_parser('install')
do_install.parser.add_argument('package', type=str)

args = main_parser.parse_args()

if args.command == 'init':
	do_init(args)
elif args.command == 'run':
	do_run(args)
elif args.command == 'configure-tool':
	do_configure_tool(args)
elif args.command == 'compile-tool':
	do_compile_tool(args)
elif args.command == 'install-tool':
	do_install_tool(args)
elif args.command == 'configure':
	do_configure(args)
elif args.command == 'build':
	do_build(args)
elif args.command == 'install':
	do_install(args)
else:
	assert not "Unexpected command"

